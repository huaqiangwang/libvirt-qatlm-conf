//
// Created by david on 2021/11/12.
//

#include <vector>
#include <string>
#include <fstream>
#include <regex>
#include <filesystem>
#include <iostream>

#include "ConfItem.h"
#include "LibvirtConf.h"

namespace LibvirtConf {

    std::vector<ConfItem>* VirtSetting::GetConf(std::string& conFile) {
        std::ifstream fConf(conFile, std::ios::in);
        if (!fConf.is_open()) {
            // How to get error
            return NULL;
        }

        std::vector<std::vector<std::string>> confTextSections;
        std::vector<std::string>* textSection = new std::vector<std::string>;

        std::string line;
        std::regex regComment("\\s*#");
        std::smatch m;
        const std::string WHITESPACE = " \n\r\t\f\v";

        while (std::getline(fConf, line)) {
            // skip empty line or line with only blanks
            if (line.find_first_not_of(WHITESPACE) == std::string::npos)
                continue;

            if (std::regex_search(line, m, regComment))
                continue;

            if (line.find("=") != std::string::npos) {
                if (!textSection->empty()) {
                    confTextSections.push_back(*textSection);
                    textSection = new std::vector<std::string>;
                }
            }
            //TODO: Pay attention to big projcts's exception handling
            textSection->push_back(line);
        }
        fConf.close();

        if (!textSection->empty())
            confTextSections.push_back(*textSection);

        for (auto section: confTextSections) {
            auto item = new ConfItem();
            item->parse(section);
            items_->push_back(*item);
        }

        return items_;
    }

    int VirtSetting::GenerateConfFile(std::string& targetName) {
        auto targetFile = std::ofstream(targetName, std::ios::out);
        if (!targetFile.is_open())
            return -1;

        targetFile << "#" << std::endl;
        targetFile << "# Auto-generated by libvirt-qatlm-conf" << std::endl;
        targetFile << "#" << std::endl;
        for (auto item: *items_){
            auto strList = item.toStrings();
            if (!strList.empty()){
                for (auto s : strList) {
                    targetFile << s << std::endl;
                }
            }
        }

        targetFile.close();
        return 0;
    }

    std::vector<std::string>*  VirtSetting::GetQATDevList() {
        std::filesystem::path uioClassPath("/sys/class/uio");
        if (!std::filesystem::exists(uioClassPath)) {
            std::cout << std::endl;
            std::cout << "\t!! No /sys/class/uio found, have you installed QAT driver?"<< std::endl;
            std::cout << "\t Stop." << std::endl;
            std::cout << std::endl;
            exit(1);
            return devs_;
        }

        const std::regex uioRegex("/sys/class/uio/(uio\\d+)");
        const std::regex qatNameRegex("c6xxvf");
        std::smatch m;

        for (const auto &entry : std::filesystem::directory_iterator(uioClassPath)) {
            auto devName = std::string(entry.path());

            if (!std::regex_search(devName, m,  uioRegex))
                continue;

            std::string devStr("/dev/");
            devStr.append(m[1].str());
            auto uioDevName = uioClassPath / devName / "name";
            if (!std::filesystem::exists(uioDevName))
                continue;

            std::ifstream uioName(uioDevName);
            if (!uioName.is_open())
                continue;

            std::string devNameContent;
            std::getline(uioName, devNameContent);
            uioName.close();

            if (!std::regex_search(devNameContent, qatNameRegex))
                continue;
            devs_->push_back(devStr);
        }

        devs_->push_back("/dev/qat_adf_ctl");
        devs_->push_back("/dev/usdm_drv");
        devs_->push_back("/dev/qat_dev_processes");

        return devs_;
    }

    void VirtSetting::UpdateQATDevices() {
        // looking for "cgroup_device_acl"
        ConfItem *qatItem = NULL;
        bool haveQATItem = false;
        for (auto& item : *items_){
            if (item.name() == "cgroup_device_acl") {
                qatItem = &item;
                haveQATItem = true;
            }
        }

        std::vector<std::string> fixedDevs{"/dev/null", "/dev/full", "/dev/zero",
                                           "/dev/random", "/dev/urandom",
                                           "/dev/ptmx", "/dev/kvm", "/dev/kqemu",
                                           "/dev/rtc","/dev/hpet", "/dev/sev"};
        if (!haveQATItem) {
            qatItem = new ConfItem("cgroup_device_acl",
                                   ItemType::ITEM_STRING_LIST,
                                   {0, "", fixedDevs});
        }

        for (auto & dev : fixedDevs ) {
            if (qatItem->InStrList(dev))
                continue;

            qatItem->InsertItemInStrList(dev);
        }

        for (auto & dev : *devs_) {
            if (qatItem->InStrList(dev))
                continue;

            qatItem->InsertItemInStrList(dev);
        }
        if (!haveQATItem)
            items_->push_back(*qatItem);
    }
}
